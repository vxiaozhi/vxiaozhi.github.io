# 代码覆盖率

代码覆盖率是软件测试中的一种度量，描述程序中源代码被测试的比例和程度，所得比例称为代码覆盖率 。

代码覆盖率指标通常包含下面几类：

- 函数/方法覆盖率：函数/方法中有多少被调用到
- 分支覆盖率：有多少控制结构的分支（例如if语句）被执行
- 条件覆盖率：有多少布尔子表达式被测试为真值和假值
- 行覆盖率：有多少行的源代码被测试过


**代码覆盖率的意义**

- 测试视角：分析未覆盖部分的代码，从而反推在前期测试设计是否充分?没有覆盖到的代码是否是测试设计的盲点，为什么没有考虑到？是需求/设计不够清晰，测试设计的理解有误？还是工程方法应用后造成的策略性放弃等等，方便之后进行测试用例设计补充。
- 开发视角：检测出程序中的废代码，可以逆向反推在代码设计中思维混乱点，提醒设计/开发人员理清代码逻辑关系，提升代码质量。
- 其他视角：代码覆盖率高不能说明代码质量高，但是反过来看，代码覆盖率低，代码质量不会高到哪里去，可以作为测试/开发自我审视的重要工具之一。

以上是代码覆盖率正面的意义，但是要注意一点：从质量的角度来说，肯定是希望用例能够对代码全部进行覆盖的，但是从实际出发，进行全覆盖也是不现实的，并且把测试覆盖率作为质量目标没有任何意义，而我们应该把它作为一种发现未被测试覆盖的代码的手段。从现有的覆盖率检测工具来看，即使覆盖率到达了100%，也不能保证用户场景完全被覆盖到或者不会出现漏测，因为从原理上来讲，代码覆盖率只能表示开发写的代码都执行了，但是不表示代码没有逻辑问题，如漏写异常处理，没有完全覆盖用户场景等。

## Lcov（cov.info） 格式解析

- [LcovParser lcov覆盖率产物解析器](https://github.com/gbfansheng/LcovParser)

## How
### 1. 全量覆盖率

适用场景：

- 初次测试：当开始进行测试时，全量代码覆盖率非常有用。它可以确保测试用例覆盖了整个代码库，从而验证代码在各种场景下的正确性和稳定性。
- 重构和优化：在进行重构或性能优化时，全量代码覆盖率可以帮助发现可能引入的新问题，并确保代码的质量和性能未受到不良影响。
- 稳定版本验证：在发布稳定版本之前，全量代码覆盖率可用于验证所有已经修改或新增的功能的测试覆盖程度，以确保发布的版本是经过全面测试的。
- 其他需要全量回归的场景，如：机房迁移，新环境部署...
  
### 2. 增量覆盖率

jacoco本身是不支持增量代码覆盖率的，但是可以通过二开或者使用其他的开源工具实现增量覆盖率报告生成。 适用场景：

- 快速迭代测试：在项目快速迭代的情况下，仅针对新增或修改的代码进行增量代码覆盖率分析能够快速确定这些变动的测试覆盖程度，以便加快迭代速度。
- 高频更新验证：对于经常更新的代码库，每次都进行全量代码覆盖率分析可能会产生高昂的计算和执行成本。使用增量代码覆盖率可以更快地了解测试覆盖的变化情况，以便快速验证新增功能的正确性和稳定性。
- 增量测试补充：当时间有限而需求变动时，增量代码覆盖率可用于快速确定需求变动对现有测试覆盖的影响，并有针对性地补充和调整测试用例，以覆盖新增或修改的代码。

为了保证代码质量，一般会要求提交的源码要有测试用例覆盖，并对测试覆盖率有一定的要求，在实践中不仅会考核存量代码覆盖率（总体覆盖率）还会考核增量代码的覆盖率。或者说增量覆盖率更有实际意义，测试用例要随源码一并提交，实时保证源码的质量，而不是代码先行，测试用例后补，这有些应付的意思。

对于存量代码覆盖率主流的测试工具（框架）都是默认支持的，配置reporter相关参数，执行完测试用例就会生成测试报告。

对于增量测试覆盖率主流的测试工具一般没有支持，我想计算增量代码貌似不是测试工具该干的事，所以主流测试工具并没有提供这一功能。

那么如果计算增量覆盖率呢？
计算增量测试覆盖率，总共需要3步

- 计算出增量代码的所有行号
- 计算出测试未覆盖的代码的所有行号
- 对比计算增量代码被测试覆盖的比例，得出增量覆盖率


在 `https://www.perplexity.ai/` 中搜索 全量代码覆盖率、增量代码覆盖率、累计代码覆盖率 会给出如下回答

```
全量代码覆盖率、增量代码覆盖率和累计代码覆盖率是衡量软件测试质量的重要指标，下面对这三种覆盖率进行详细解释。
全量代码覆盖率
定义：全量代码覆盖率是指在整个代码库中，经过测试用例执行后，实际被执行的代码行数与总代码行数的比例。它通常用于评估整个项目或模块的测试充分性。
目标：一般要求全量代码覆盖率达到70%至80%之间，以确保大部分代码路径都经过测试12。
增量代码覆盖率
定义：增量代码覆盖率是指在特定版本或迭代中新增或修改的代码行被测试用例覆盖的比例。它主要用于评估每次迭代对新代码的测试情况。
目标：增量代码覆盖率通常要求更高，服务端项目可能要求达到80%-90%，而移动端和前端项目则要求70%-80%13。这种高标准确保新功能或修复的可靠性。
累计代码覆盖率
定义：累计代码覆盖率是指在整个开发周期内，所有版本中被测试用例执行过的代码行数与总代码行数的比例。它反映了随着时间推移，项目整体的测试情况。
目标：累计代码覆盖率通常会随着项目的发展而提高，开发团队会设定阶段性目标，例如核心业务代码分支覆盖率达到50%或更高12。
总结
这三种覆盖率各有侧重，全量代码覆盖率关注整体质量，增量代码覆盖率强调新功能的可靠性，而累计代码覆盖率则反映了长期的测试成果。通过合理设置这些指标，可以有效提升软件质量和降低潜在风险。
```

**参考**

- [如何计算增量测试覆盖率](https://juejin.cn/post/6850418111573655565)
- [jacoco-diff 在 jacoco 覆盖率报告的基础上，计算出增量覆盖率](https://github.com/raoweijian/jacoco-diff)
- [增量代码覆盖率](https://github.com/erduoniba/hdcoverage/blob/master/Coverage_Gather.md)

### 3. 累计代码覆盖率 

累计代码覆盖率首先得解决不同版本代码合并得问题。

**跨版本合并**

跨版本，代码合并的流程大致如下：

```
# Pathnames in the diff file need to be absolute (note
# to self: document)
diff -u $(PWD)/hello_old.c $(PWD)/hello_new.c > difffile

# Without --convert-filenames, the data from RUN1 will
# still be associated with hello_old.c
lcov --diff RUN1.INFO difffile --convert-filenames -o RUN1_CONVERTED.INFO

# Add data from both runs
lcov -a RUN1_CONVERTED.INFO -a RUN2.INFO -o RUN_ALL.INFO
```


## 平台

- [DiffTestPlatform 基于python编写的代码变更覆盖率平台](https://github.com/hzlifeng1/DiffTestPlatform)
- [vivo 基于 JaCoCo 的测试覆盖率设计与实践](https://www.cnblogs.com/vivotech/p/16627491.html)
- [基于 Jacoco 的 java 代码覆盖率收集服务设计](https://geeknote.net/wick/posts/2577)
  
## 参考

